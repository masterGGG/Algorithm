/*
题目描述
在河上有一座独木桥，一只青蛙想沿着独木桥从河的一侧跳到另一侧。在桥上有一些石子，青蛙很讨厌踩在这些石子上。
由于桥的长度和青蛙一次跳过的距离都是正整数，我们可以把独木桥上青蛙可能到达的点看成数轴上的一串整点：0,1,…,L（其中L是桥的长度）。
坐标为0的点表示桥的起点，坐标为L的点表示桥的终点。青蛙从桥的起点开始，不停的向终点方向跳跃。
一次跳跃的距离是S到T之间的任意正整数（包括S,T）。当青蛙跳到或跳过坐标为L的点时，就算青蛙已经跳出了独木桥。
题目给出独木桥的长度L，青蛙跳跃的距离范围S,T，桥上石子的位置。你的任务是确定青蛙要想过河，最少需要踩到的石子数。
输入格式
第一行有1个正整数L(1 ≤ L ≤10^9)，表示独木桥的长度。
第二行有3个正整数S,T,M，分别表示青蛙一次跳跃的最小距离，最大距离及桥上石子的个数，其中1≤S≤T≤10,1≤M≤100。
第三行有M个不同的正整数分别表示这M个石子在数轴上的位置（数据保证桥的起点和终点处没有石子）。所有相邻的整数之间用一个空格隔开。

输出格式
一个整数，表示青蛙过河最少需要踩到的石子数。

10
2 3 5 
2 3 5 6 7

说明/提示
对于30%的数据，10000≤L≤10000；
对于全部的数据，10^9≤L≤109。
*/

#include <bits/stdc++.h>
using namespace std;
const int N = 2e5 + 5;
int L, _min, _max, num, dis, res, a[N], dp[N], vis[N];
int main() {
  cin >> L >> _min >> _max >> num;
  for (int i = 1; i <= num; i++) cin >> a[i];
  if (_min == _max) {
    for (int i = 1; i <= num; i++) {
      if (a[i] % _min == 0) res++;
    }
    cout << res << '\n';
    return 0;
  }
  sort(a + 1, a + num + 1);
  int len = _min * _max;
  for (int i = 1; i <= num; i++) {
    int d = a[i] - a[i - 1];
    if (d > len) d = len;
    dis += d;
    vis[dis] = 1;
  }
  for (int i = dis; i >= 0; i--) {
    dp[i] = 100;
    for (int j = _min; j <= _max; j++) {
      dp[i] = min(dp[i], dp[i + j] + vis[i]);
    }
  }
  cout << dp[0] << endl;
  return 0;
}