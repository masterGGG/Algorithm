class Solution {
public:
    bool stoneGameIX(vector<int>& stones) {
        vector<int> nums(3);
        for (auto stone : stones)
            ++nums[stone % 3];
        
        //不考虑石头中有3的倍数个的石头的话，A先手只有两种情况:
        //先拿1： B若要不失败，则只能拿1，然后A只能拿2，B只能拿1，A继续只能拿2，
        //        如此A2B1循环，直到有一种石子没有，此时根据剩的石子判断获胜方: 剩2时，A胜利
        //先拿2： B若要不失败，则只能拿2，然后A只能拿1，B只能拿2，A继续只能拿1，
        //        如此A1B2循环，直到有一种石子没有，此时根据剩的石子判断获胜方: 剩1时，A胜利
        //因此，此时若1和2的数量均不少于1，A只要选择数量少的那种石子即可。A必胜
        //而如果1或者2有一方的数量为0，则A必败，因为A第二次选择时只能拿和B刚才选择的石头相同的石头
        if (nums[0] % 2 == 0){ //偶数个恰好为3的倍数的石头
            if (nums[1] > 0 && nums[2] > 0) return true;
            else return false;
        }
        //当考虑有数量为3的倍数的石头时，相当于多了换手机会
        //如果石头数量为偶数，则没有影响(总能转回到没有数量为3的倍数的石头的情况)
        //若石头数量为奇数，则可以认为是A和B更换了先后手顺序
        //则此时，我们可以考虑A的必胜策略为拿光一种石子，然后逼迫B只能选择和自己之前的必败策略同样的行为(1或者2有一方的数量为0,然后B两次选择同样的石头)
        //而若两种石子的数量差不超过2，则A必败(B必胜): B转为了先手，而A无法拿成只剩下1或者只剩下2的情形，B总是可以通过拿数量少的那种石子获得胜利
        else{ //奇数个恰好为3的倍数的石头
            return abs(nums[1] - nums[2]) > 2;
        }
    }
};