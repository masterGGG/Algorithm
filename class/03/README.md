# 01
用数组结构实现大小固定的队列和栈
# 02
实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返
回栈中最小元素的操作。
【要求】 1.pop、push、getMin操作的时间复杂度都是O(1)。 2.设计的栈类型可以使用现成的栈结构。
# 03
如何仅用队列结构实现栈结构?
如何仅用栈结构实现队列结构?
# 04
猫狗队列 【题目】 宠物、狗和猫的类如下:
public class Pet { private String type;
public Pet(String type) { this.type = type; } public String getPetType() { return this.type; } }
public class Dog extends Pet { public Dog() { super("dog"); } } public class Cat extends Pet { public Cat() { super("cat"); } }
实现一种狗猫队列的结构，要求如下: 用户可以调用add方法将cat类或dog类的 实例放入队列中; 用户可以调用pollAll方法，将队列中所有的实例按照进队列 的先后顺序依次弹出; 用户可以调用pollDog方法，将队列中dog类的实例按照 进队列的先后顺序依次弹出; 用户可以调用pollCat方法，将队列中cat类的实 例按照进队列的先后顺序依次弹出; 用户可以调用isEmpty方法，检查队列中是 否还有dog或cat的实例; 用户可以调用isDogEmpty方法，检查队列中是否有dog 类的实例; 用户可以调用isCatEmpty方法，检查队列中是否有cat类的实例。
# 05
转圈打印矩阵
【题目】 给定一个整型矩阵matrix，请按照转圈的方式打印它。 例如:1 2 3 45 6 7 89 10 11 121314
15 16 打印结果为:1，2，3，4，8，12，16，15，14，13，9， 5，6，7，11， 10
【要求】 额外空间复杂度为O(1)。
# 06
旋转正方形矩阵
【题目】 给定一个整型正方形矩阵matrix，请把该矩阵调整成 顺时针旋转90度的样子。
【要求】 额外空间复杂度为O(1)。
# 07
反转单向和双向链表
【题目】 分别实现反转单向链表和反转双向链表的函数。 【要求】 如果链表长度为N，时间复杂度要求为O(N)，额外空间 复杂度要求为O(1)
# 08
“之”字形打印矩阵
【题目】 给定一个矩阵matrix，按照“之”字形的方式打印这 个矩阵，例如:1 2 3 45 6 7 89 10 11 12 “之”字形打印的结果为:1，2，5，9，6，3，4，7，10，11， 8，12
【要求】 额外空间复杂度为O(1)。
# 09
在行列都排好序的矩阵中找数
【题目】 给定一个有N*M的整型矩阵matrix和一个整数K， matrix的每一行和每一 列都是排好序的。实现一个函数，判断K 是否在matrix中。 例如: 0 1 2 5 2 3 4 7 4
4 4 8 5 7 7 9 如果K为7，返回true;如果K为6，返 回false。
【要求】 时间复杂度为O(N+M)，额外空间复杂度为O(1)。
# 10
打印两个有序链表的公共部分
【题目】 给定两个有序链表的头指针head1和head2，打印两个 链表的公共部分。
# 11
判断一个链表是否为回文结构
【题目】 给定一个链表的头节点head，请判断该链表是否为回 文结构。 例如: 1->2->1，返回true。 1->2->2->1，返回true。 15->6->15，返回true。 1->2->3，返回false。
进阶: 如果链表长度为N，时间复杂度达到O(N)，额外空间复杂 度达到O(1)。
# 12
将单向链表按某值划分成左边小、中间相等、右边大的形式
【题目】 给定一个单向链表的头节点head，节点的值类型是整型，再给定一个 整 数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于 pivot 的节点，中间部分都是值等于pivot的节点，右部分都是值大于 pivot的节点。 除这个要求外，对调整后的节点顺序没有更多的要求。 例如:链表9->0->4->5- >1，pivot=3。 调整后链表可以是1->0->4->9->5，也可以是0->1->9->5->4。总 之，满 足左部分都是小于3的节点，中间部分都是等于3的节点(本例中这个部 分为空)，右部分都是大于3的节点即可。对某部分内部的节点顺序不做 要求。
进阶: 在原问题的要求之上再增加如下两个要求。 在左、中、右三个部分的内部也做顺序要求，要求每部分里的节点从左 到右的 顺序与原链表中节点的先后次序一致。 例如:链表9->0->4->5->1，pivot=3。 调整后的链表是0->1->9->4->5。 在满足原问题要求的同时，左部分节点从左到 右为0、1。在原链表中也 是先出现0，后出现1;中间部分在本例中为空，不再 讨论;右部分节点 从左到右为9、4、5。在原链表中也是先出现9，然后出现4， 最后出现5。 如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。
# 13
复制含有随机指针节点的链表
【题目】 一种特殊的链表节点类描述如下:
public class Node { public int value; public Node next; public Node rand;
public Node(int data) { this.value = data; }
} Node类中的value是节点值，next指针和正常单链表中next指针的意义 一 样，都指向下一个节点，rand指针是Node类中新增的指针，这个指 针可 能指向链表中的任意一个节点，也可能指向null。 给定一个由 Node节点类型组成的无环单链表的头节点head，请实现一个 函数完成 这个链表中所有结构的复制，并返回复制的新链表的头节点。 进阶: 不使用额外的数据结构，只用有限几个变量，且在时间复杂度为 O(N) 内完成原问题要实现的函数。
# 14
两个单链表相交的一系列问题
【题目】 在本题中，单链表可能有环，也可能无环。给定两个 单链表的头节点 head1和head2，这两个链表可能相交，也可能 不相交。请实现一个函数， 如果两个链表相交，请返回相交的 第一个节点;如果不相交，返回null 即可。 要求:如果链表1 的长度为N，链表2的长度为M，时间复杂度请达到 O(N+M)，额外 空间复杂度请达到O(1)。
# 15